#! /usr/bin/env python2.7
## -*- encoding: utf-8 -*-



## Functions for calculating molecular orbitals and electron density differences.

from physics import A_to_a0, ea0_to_D, pm_to_a0
from orbkit import core
import numpy as np
## Patched version of orbkit.read
import read



## Get grid parameters and initialize grid
def _init_ORB_grid(data, grid_par=-6, over_s=7):
	u"""Initializes ORBKIT's grid and returns necessary data for visualization.
	**Parameters:**

	  data : dict
	QCinfo instance representing the molecule.
	  grid_par : int
	Parameter controlling grid. If positive or zero, it specifies number of points; otherwise it specifies the resolution in inverse atomic units.
	  over_s : int|float
	Oversizing, to be tuned

	**Returns**
	  X, Y, Z
	Meshgrid (as returned by numpy.mgrid) for positioning the voxels.
	"""

	from orbkit import grid

	## Spacing/Number of points
	if grid_par > 0:
		grid.N_ = [grid_par]*3
	elif grid_par == 0:
		grid.N_ = [80]*3
	else:
		grid.delta_ = [1.0/(-grid_par)]*3

	grid.max_ = np.amax(data.geo_spec, axis=0) + over_s
	grid.min_ = np.amin(data.geo_spec, axis=0) - over_s

	grid.init()

	## The meshgrid MUST be generated in this manner,
	## in order to be maximally consistent with ORBKIT
	## which uses numpy.arange to generate its grid
	## (i.e. start:stop+step:step)
	X, Y, Z = np.mgrid[grid.min_[0] : grid.max_[0] + grid.delta_[0] : grid.delta_[0],
                           grid.min_[1] : grid.max_[1] + grid.delta_[1] : grid.delta_[1],
                           grid.min_[2] : grid.max_[2] + grid.delta_[2] : grid.delta_[2]]
	## NOTICE: numpy.arange does not return consistent results if step is a float,
	## specifically if (stop - start)/step overflows, resulting in
	## arange(start, stop, step)[-1] > stop

	return X, Y, Z

## TODO: Consider (alpha and beta orbitals|open shells|unpaired electrons)


## Calculations
def MO(j_data, MO_list, grid_par=-6):
	u"""Calculates the voxels representing the requested molecular orbitals of a molecule.
	** Parameters **
	  j_data : dict
	Data on the molecule, deserialized from the scanlog format.
	  MO_list : list(str) or list(int)
	A list containing either:
	  - integers designating the molecular orbitals (starting from 1)
	  - strings designating the molecular orbitals either through:
	    - keywords (e.g. "homo", "lumo")
	    - ranges (e.g. "homo-1:lumo+2")
	    - symmetries (e.g. "5.A")
	  grid_par : int, optional
	Governs the grid to be used for the voxels.
	  - If positive, it indicates the number of points in all 3 dimensions.
	  - If zero, it indicates the default number of points (80).
	  - If negative, it indicates the resolution, in (A.U.)^-1.
	** Returns **
	  out : list(numpy.ndarray)
	List of numpy.ndarrays, each one containing the values of the probability amplitude of a single molecular orbital at each voxel of the grid.
	  X, Y, Z : numpy.ndarray
	Meshgrids (as generated by numpy.mgrid) required for positioning the voxel values contained in out.
	"""

	## Prepare data for ORBKIT
	qc = read.convert_json(j_data, all_mo=True)
	X, Y, Z = _init_ORB_grid(qc, grid_par=grid_par)

	## Get list of orbitals
	qc.mo_spec = read.mo_select(qc.mo_spec, MO_list)["mo_spec"]

	## Calculate
	out = core.rho_compute(qc, calc_mo=True, numproc=4)

	return out, X, Y, Z



def _density_difference_MOs(transitions):
	u"""Determines the molecular orbitals involved in electron transitions.
	** Parameters **
	  transitions : list
	Structured list, each element containing the following data for a single transition:
	  - Initial and final states:
	    - Molecular orbital
	    - Spin
	  - Coefficient
	** Returns **
	  MO_set : set
	The set of molecular orbitals to calculate
	  tab : dict
	A translation dictionary mapping the molecular orbitals to indices.
	"""

	## Get all MOs involved in transitions
	MO_list = [STT[0] for T in transitions for ST in T for STT in ST[:2]]
	MO_set = set(MO_list)
	## The dictionary is needed because the MO numbers do not correspond
	## to their indices in the output of rho_compute, and we can only access
	## them through indices (assuming ORBKIT conserves the order of the MO
	## numbers in qc.mo_spec)
	tab = dict([(MO, i) for i, MO in enumerate(MO_set)])

	return MO_set, tab



def TD(j_data, transitions, grid_par=-6):
	u"""Calculates diverse data on the requested transitions of a molecule.
	** Parameters **
	  j_data : dict
	Data on the molecule, as deserialized from the scanlog format.
	  transitions : list
	A list of integers designating the transitions to consider (starting from 0)
	  grid_par : int, optional
	Governs the grid to be used for voxel data.
	  - If positive, it indicates the number of points in all 3 dimensions.
	  - If zero, it indicates the default number of points (80).
	  - If negative, it indicates the resolution, in Á^-1.
	** Returns ** 
	  out: list(tuple)
	List of tuples containing:
	 - sequences of voxels representing the density difference;
	 - Tozer (covering) coefficient of the MOs;
	 - A tuple containing:
	   - The electron displacement, in picometres
	   - The transferred charge
	   - The dipole moment, in Debye
	   - The positions of the positive and negative barycenters, respectively, in A.U.

	  X, Y, Z : numpy.ndarray
	Meshgrids (as generated by numpy.mgrid), required for placing the voxels contained in out.
	"""

	## To save time, the calculation is done in two phases:

	## 1. Get all MOs involved in transitions and calculate them once
	MO_set, tab = _density_difference_MOs(transitions)

	MOs, X, Y, Z = MO(j_data, [str(O + 1) for O in MO_set], grid_par=grid_par)

	dx, dy, dz = (X[10,0,0] - X[9,0,0]), (Y[0,10,0] - Y[0,9,0]), (Z[0,0,10] - Z[0,0,9])
	d3r = dx*dy*dz
	print d3r

	## 2. Combine MOs according to info in `et_transitions`
	out = []
	for i, T in enumerate(transitions):
		vox_data = np.zeros(MOs[0].shape)
		tozer = 0
		for j, ST in enumerate(T):
			print "Calculating transition {}.{}".format(i, j)
			## Dp_i = S_j(C_ij**2*(MO2_ij**2 - MO1_ij**2))
			MO_end, MO_start = MOs[tab[ST[1][0]]], MOs[tab[ST[0][0]]]
			rho_end, rho_start = np.square(MO_end), np.square(MO_start)
			vox_data += ST[2]**2*(rho_end - rho_start)

			## Tozer_i = S_j(C_ij**2*(|MO2_ij|*|MO1_ij|))
			abs_MO_end, abs_MO_start = np.abs(MO_end), np.abs(MO_start)
			tozer += ST[2]**2*np.sum(abs_MO_end*abs_MO_start)*d3r

		P_i, N_i = vox_data > 0.0, vox_data < 0.0

		DDp, Xp, Yp, Zp = vox_data[P_i], X[P_i], Y[P_i], Z[P_i]
		DDn, Xn, Yn, Zn = vox_data[N_i], X[N_i], Y[N_i], Z[N_i]
		Qctp, Qctn = np.sum(DDp)*d3r, np.sum(DDn)*d3r
		Pp = np.array([np.sum(DDp*Xp)*d3r/Qctp + dx/2.0, np.sum(DDp*Yp)*d3r/Qctp + dy/2.0, np.sum(DDp*Zp)*d3r/Qctp + dz/2.0])
		Pn = np.array([np.sum(DDn*Xn)*d3r/Qctn + dx/2.0, np.sum(DDn*Yn)*d3r/Qctn + dy/2.0, np.sum(DDn*Zn)*d3r/Qctn + dz/2.0])
		D = np.sqrt(np.sum(np.square(Pp - Pn)))
		Mu = D*Qctp/ea0_to_D

		out += [(vox_data, tozer, (D*pm_to_a0, Qctp, Mu, Pp, Pn))]

	return out, X, Y, Z



def Potential(j_data, grid_par=-6):
	u"""Calculates the electric potential difference for the molecule.
	** Parameters **
	  j_data : dict
	Data on the molecule, as deserialized from the scanlog format.
	  grid_par : int, optional
	Governs the grid to be used for voxel data.
	  - If positive, it indicates the number of points in all 3 dimensions.
	  - If zero, it indicates the default number of points (80).
	  - If negative, it indicates the resolution, in Á^-1.
	** Returns **
	  rho : numpy.ndarray
	The voxels containing the scalar values of the density.
	  V : numpy.ndarray
	The voxels containing the scalar values of the potential.
	  X, Y, Z : numpy.ndarray
	Meshgrids (as generated by numpy.mgrid), required for placing the voxels contained in rho and V.
	"""

	qc = read.convert_json(j_data)

	X, Y, Z = _init_ORB_grid(qc, grid_par=grid_par)

	dx, dy, dz = (X[10,0,0] - X[9,0,0]), (Y[0,10,0] - Y[0,9,0]), (Z[0,0,10] - Z[0,0,9])
	d3r = dx*dy*dz

	rho = core.rho_compute(qc, numproc=4)

	rho_T = np.sum(rho)*d3r
	P = np.array([X, Y, Z])

	## The potential can be separated into two terms
	## V_n, the contribution from nuclear charges
	V_n = np.ndarray(rho.shape)
	for i in range(len(qc.geo_spec)):
		## This currently works by:
		## 1. reshaping the atom position triplet to the shape of the meshgrids
		## 2. calculating the norm accross the three dimensions
		## 3. propagating the meshgrid shape to the charge
		V_n += float(qc.geo_info[i,-1])/np.linalg.norm(P - qc.geo_spec[i].reshape((3,1,1,1)), axis=0)

	print "Rho : ", rho_T, "(", np.min(rho)," ... ", np.max(rho),")"
	print X[0,0,0], Y[0,0,0], Z[0,0,0]
	TIx, TIy, TIz = rho.shape
	Tx, Ty, Tz = X[-1,0,0] - X[0,0,0], Y[0,-1,0] - Y[0,0,0], Z[0,0,-1] - Z[0,0,0]


	## V_r, the contribution from the electron density
	## To avoid calculating the full volume integral,
	## we consider rho as a kernel and apply it to
	## the grid of inverse distances as though it
	## were an image

	## 1. Accumulate local potential
	V_r = np.ones(rho.shape)*rho

	## Reverse rho, so that it is traversed in the
	## same direction as the image matrix
	rho_r = rho[::-1,::-1,::-1].copy()

	## 2. Extend grid
	P_ = np.array(np.mgrid[ X[0,0,0] - Tx : X[-1,0,0] + dx : dx,
	                        Y[0,0,0] - Ty : Y[0,-1,0] + dy : dy,
	                        Z[0,0,0] - Tz : Z[0,0,-1] + dz : dz ])
	print P.shape, P_.shape

	## 3. Calculate distance grid
	D = np.linalg.norm(np.array([0,0,0]).reshape((3,1,1,1)) - P_, axis=0)
	D[TIx - 1, TIy - 1, TIz - 1] = np.inf
	R = 1/D

	## 4. Convolute
	for i in xrange(TIx):
		ie = i + TIx
		for j in xrange(TIy):
			je = j + TIy
			for k in xrange(TIz):
				V_r[i,j,k] += (rho_r * R[i:ie, j:je, k:k + TIz]).sum()

	#V_r = np.zeros(rho.shape)

	#for i in xrange(TIx):
	#	for j in xrange(TIy):
	#		for k in xrange(TIz):
	#			D = 1/np.linalg.norm(P[:,i,j,k].reshape((3,1,1,1)) - P, axis=0)
	#			D[np.isinf(D)] = 0
	#			V_r[i,j,k] += np.sum(rho*D)

	V_r *= d3r

	return rho, V_n - V_r, X, Y, Z

def Fukui(j_data, grid_par=-6):
	u"""Calculates the density differences/Fukui functions of the molecule.
	** Parameters **
	  j_data : dict
	Data on the molecule, as deserialized from the scanlog format.
	  grid_par : int, optional
	Governs the grid to be used for voxel data.
	  - If positive, it indicates the number of points in all 3 dimensions.
	  - If zero, it indicates the default number of points (80).
	  - If negative, it indicates the resolution, in Á^-1.
	** Returns **
	  X, Y, Z : numpy.ndarray
	Meshgrids (as generated by numpy.mgrid), required for placing the voxels contained in rho and V.
	"""
	pass
